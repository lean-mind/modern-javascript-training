import {CodeSurfer} from "code-surfer";
import {highlight} from 'mdx-deck/themes'
import {Notes} from 'mdx-deck'

export const theme = highlight

import { Logo, Table, Column } from './components'
import logo from './assets/logo.png'
import callbackHell from './assets/callback-hell.png'

# Javascript Moderno

<img src={logo} width="250px"/>

<Logo/>

<Notes>

  - https://devhints.io/es6
  - 쯈u칠 se considera JavaScript moderno? Podemos definir como JavaScript moderno al JavaScript a partir de ES2015, ya que a partir de esta versi칩n el lenguaje di칩 un salto de calidad. Esto sumado al compromiso por parte de Ecma international y la comunidad de JavaScript de lanzar una nueva versi칩n cada a침o a침adiendo las nuevas funcionalidades. Todo esto junto con Node.js conllev칩 a una explosi칩n en cuanto al uso del lenguaje y herramientas del ecosistema. Todo esto permite un desarrollo en JavaScript m치s r치pido y seguro que antes.

</Notes>

---

### 춰Novedades!

<Table>
  <Column title="ES2015">
    <ul>
      <li>Variable Scoping</li>
      <li>Arrow functions</li>
      <li>Classes</li>
      <li>Enhanced object literals</li>
      <li>Template literals</li>
      <li>Destructuring</li>
      <li>Default parameters</li>
      <li>Rest parameter</li>
      <li>Spread Operator</li>
      <li>Iterators & For..of</li>
      <li>Generators</li>
      <li>Modules</li>
      <li>Set</li>
      <li>Weakset</li>
      <li>Map</li>
      <li>Weakmap</li>
      <li>Unicode</li>
      <li>Proxies</li>
      <li>Symbols</li>
      <li>Promises</li>
      <li>Reflect</li>
      <li>Binary and Octal</li>
      <li>Proper Tail calls</li>
      <li>Array find methods</li>
    </ul>
  </Column>
  <Column title="ES2016">
    <ul>
      <li>Array includes</li>
      <li>Exponentiation Operator</li>
    </ul>
  </Column>
  <Column title="ES2017">
    <ul>
      <li>Async functions</li>
      <li>Object values</li>
      <li>Object entries</li>
      <li>Object property descriptors</li>
      <li>String padding</li>
      <li>Shared memory and atomics</li>
      <li>Trailing commas</li>
    </ul>
  </Column>
  <Column title="ES2018">
    <ul>
      <li>Async iterators</li>
      <li>Object rest and spread operators</li>
      <li>Promise finally</li>
    </ul>
  </Column>
  <Column title="ES2019">
    <ul>
      <li>Array flat and flatMap</li>
      <li>Object fromEntries</li>
      <li>String trimStart and trimEnd</li>
      <li>Symbol description</li>
      <li>Optional Catch Binding</li>
      <li>JSON Improvements</li>
      <li>Array Stable Sort</li>
      <li>Function.toString()</li>
      <li>Private Class Variable</li>
    </ul>
  </Column>
  <Column title="ES2020">
    <ul>
      <li>BigInt</li>
      <li>Dynamic Import</li>
      <li>Nullish Coalescing Operator</li>
      <li>Optional chaining</li>
      <li>Promise allSettled</li>
      <li>String matchAll</li>
      <li>globalThis</li>
      <li>import.meta</li>
      <li>for..in order</li>
    </ul>
  </Column>
  <Column title="ES2021">
    <ul>
      <li>String replaceAll</li>
      <li>Promise any</li>
      <li>AggregateError</li>
      <li>Logical assigment operators (??=, &&=, ||=)</li>
      <li>WeakRef</li>
      <li>FinalizationRegistry</li>
      <li>Separators for numeric literals (1_000)</li>
      <li>Array.prototype.sort</li>
    </ul>
  </Column>
</Table>

<Logo/>

<Notes>

  - Esto son todas las cosas nuevas que han entrado desde 2015,
    pero esto no significa que vayamos a presentarlas todas, es para que les entre curiosidad

</Notes>

---

<CodeSurfer>

```javascript title="Variable scoping"
var a = 1;

if (a === 1) {
  var a = 2;

  console.log(a); // 2
}

console.log(a); // 2
```

```javascript title="Variable scoping"
let a = 1;

if (a === 1) {
  let a = 2;

  console.log(a); // 2
}

console.log(a); // 1
```

```javascript title="Variable scoping"
const x = 1;

if (x === 1) {
  const x = 2;

  console.log(x); // 2
}

console.log(x); // 1
```

```javascript title="Variable scoping"
const x = 1;

if (x === 1) {
  const x = 2;

  console.log(x); // 2
}
x = 3 // throw SyntaxError

console.log(x); // 1
```

</CodeSurfer>

<Logo/>

<Notes>

  - `var` es como se han definido variables en JavaScript desde el principio de los tiempos. Sin embargo, presenta una serie de problemas:
    - Su 치mbito es global dentro de la funci칩n que est치, por lo que desde cualquier lugar de la funci칩n puedes llegar a cambiar algunos valores derivando en resultados inesperados. `let` y `const` lanzar칤an un `ReferenceError`
    - Puede ser usada antes de ser declarada, usando `let` o `const` lanzar칤a un `ReferenceError`
    -

</Notes>

---

## Modules

```javascript title="Ecma Script Modules"
// fileA.js
export const meaningOfLife = 42

...
// fileB.js

import { meaningOfLife } from './fileA'

console.log(meaningOfLife) // 42
```

<Logo/>

<Notes>

  - Antes de 2015 JavaScript como lenguaje no ten칤a manera de dividir el c칩digo en ficheros o m칩dulos e ir import치ndolos entre ellos para reusar c칩digo y no tener un fichero kilom칠trico. Exist칤an librer칤as como RequireJS que permit칤an, pero no era ning칰n est치ndar.
  - Con 2015 llegaron los conocidos como ES Modules para dar una forma estandarizada en el lenguaje para importar y exportar c칩digo entre ficheros JavaScript.

</Notes>

---

<CodeSurfer>

```javascript title="Arrow functions"
// Function
const add = function (a, b) {
  return a + b;
}

// Arrow function
const add = (a, b) => a + b
```

</CodeSurfer>

<Logo/>

<Notes>

  - Aunque parezca que es az칰car sint치ctico, realmente hay una ligera diferencia. En el caso de las funciones de toda la vida, tienen su propio this, mientras que las arrow functions usan el this del scope en el que est치n.
  - Las arrow functions es mejor usarlas como funciones an칩nimas, como m칠todos y dem치s dar치n errores, ya que no tienen ni idea del this.

</Notes>

---

<CodeSurfer>

```javascript title="Default parameters in functions"
const add = (a = 10, b = 20) => a + b

add(5, 5) // 10
add(5)    // 25
add()     // 30
```

</CodeSurfer>

<Logo/>

<Notes>

  - Los par치metros por defecto em las funciones pueden ser llamadas a otras funciones en incluso otros par치metros anteriores.

</Notes>

---

## Asincron칤a

<Logo/>

<Notes>

  - Vamos a hablar muy brevemente de la asincron칤a.

</Notes>

---

## Asincron칤a - Antes de las promesas


<CodeSurfer>

```javascript title="Ejemplo de callback"
button.addEventListener('click', function(){
   alert('Alerta')
});
```

</CodeSurfer>


<Logo/>

<Notes>

  - La gesti칩n de asincron칤a antes de 2015 se hac칤a por callbacks, lo cual hac칤a todo muy dif칤cil de debuggear y leer, ya que se originaban los famosos callback hells.

</Notes>

---

## Asincron칤a - Antes de las promesas


<img src={callbackHell} />

<Logo/>

<Notes>

  - A esto es a lo que me refiero cuando hablo de callback hell.

</Notes>

---

## Asincron칤a - Promesas

```javascript title="Ejemplo de Promise"
function delay() {
  return new Promise((resolve, reject) => {
    if (Math.random() > 0.5) {
      return resolve(42)
    } else {
      return reject(new Error('游눤 Boom!!'))
    }
  })
}
```

<Logo/>

<Notes>

  -

</Notes>

---

```javascript title="Ejemplo de Promise"
delay()
  .then((result) => {
    console.log(`Received ${result}.`)
  })
  .catch((err) => {
    console.error(`Error ${err.toString()} received.`)
  })
  .finally(() => {
    console.log('I am executed even if promise is resolved or rejected')
  })
```

<Logo/>

<Notes>

  -

</Notes>

---

## Asincron칤a - async/await

```javascript title="Ejemplo de async/await"
async function delay() {
  if (Math.random() > 0.5) {
    return 42
  } else {
    throw new Error('游눤 Boom!!')
  }
}
```

<Logo/>

<Notes>

  - Toda funci칩n con la keyword async devuelve una promesa. Dicho de otra manera, toda funci칩n as칤ncrona devuelve una promesa.

</Notes>

---

## Asincron칤a - async/await

```javascript title="Ejemplo de async/await"
try {
  const result = await delay()
  console.log(`Received ${result}.`)
} catch (err) {
  console.error(`Error ${err.toString()} received.`)
} finally {
  console.log('I am executed even if promise is resolved or rejected')
}
```

<Logo/>

<Notes>

  - El await siempre debe ser usado dentro de una funci칩n as칤ncrona (En Node.js llegar치 en breve la opci칩n de poder usarlo a nivel global).

</Notes>

---

## Arrays - M칠todos nuevos

<CodeSurfer>

```js title="Array.prototype.find"
const numberList = [10, 20, 30, 40, 50]

numberList.find(x => x > 25) // 30
```

```js title="Array.prototype.find"
const numberList = [10, 20, 30, 40, 50]

numberList.find(x => x > 60) // undefined
```

</CodeSurfer>

<Logo/>

<Notes>

  - Devuelve el primer elemento que resuelva satisfactoriamente la condici칩n.
  - Si no lo encuentra devuelve undef

</Notes>

---

## Arrays - M칠todos nuevos

<CodeSurfer>

```js title="Array.prototype.includes"
const numberList = [10, 20, 30, 40, 50]

numberList.includes(20) // true
numberList.includes(25) // false
```

</CodeSurfer>

<Logo/>

<Notes>

  - Muy 칰til para valores primitivos, pero algo inestable para objetos, ya que comparar치 por referencia y no por valor.

</Notes>

---

## Arrays - Destructuring

<CodeSurfer>

```js title="Array destructuring"
const [one, two, three] = [1,2,3]

one // 1
two // 2
three // 3
```

```js title="Array destructuring"
const [one, two, three, four] = [1,2,3]

one // 1
two // 2
three // 3
four // undefined
```

```js title="Array destructuring"
const [one, two, three] = 'Hi!'

one // 'H'
two // 'i'
three // '!'
```

</CodeSurfer>

<Logo/>

<Notes>

  - Ponemos ejemplos y explicamos sobre array, pero realmente este tipo de destructuring se puede aplicar a cualquier iterable (Por ejemplo a un String o un Set).
  - Se basa a en las posiciones

</Notes>

---

## Arrays - Destructuring

<CodeSurfer>

```js title="Rest parameter"
const [ten, ...restOfNumbers] = [10, 20, 30, 40, 50]

ten // 10
restOfNumbers // [20, 30, 40, 50]
```

```js title="Rest parameter"
  const [ten, ...restOfNumbers, fifty] = [10, 20, 30, 40, 50]
  // throw SyntaxError: Rest element must be last element
```

</CodeSurfer>

<Logo/>

<Notes>

  - Los rest parameters se usa para agrupar todos los elementos restantes del array en una variable. Es como decir quiero esto, aquello y lo otro y el resto me lo pones en un tupper para llevar.
  - Debe ser el 칰ltimo valor, de lo contrario lanzar치 un SyntaxError
  - En el caso de rest parameter el uso de la elipsis se hace de cara a la definici칩n de la variable.

</Notes>

---

## Arrays - Destructuring

<CodeSurfer>

```js title="Spread operator"
const workdays = ['Lunes', 'Martes', 'Mi칠rcoles', 'Jueves', 'Viernes']
const weekend = ['S치bado', 'Domingo']
const week = [...workdays, ...weekend]

week // [ "Lunes", "Martes", "Mi칠rcoles", "Jueves", "Viernes", "S치bado", "Domingo"]
```

</CodeSurfer>

<Logo/>

<Notes>

  - El spread operator al contrario que el rest parameters divide en vez de agrupar.
  - Se suele usar mucho para clonar arrays, ya que al usarlo genera un nuevo array de cero, en vez de hacer referencias a memoria.
  - El orden en el que hacemos el spread importa, ya que el array final seguir치 ese orden.
  - En el caso del spread operator el uso de la elipsis se hace de cara a la asignaci칩n de la variable.

</Notes>

---

## Arrays - Destructuring

Art칤culo que explica el destructuring de Array:

[https://ulisesantana.dev/blog/2021/array-destructuring/](https://ulisesantana.dev/blog/2021/array-destructuring/)

<Logo/>

<Notes>

  -

</Notes>

---

## Arrays - For of

<CodeSurfer>

```js title="For of"
const numberList = [10, 20, 30, 40, 50]

for (const value of numberList) {
  console.log(value)
}
```

```js title="For of"
const numberList = [10, 20, 30, 40, 50]

for (const [index, value] of numberList.entries()) {
  console.log(`Number ${value} at position ${index}`)
}
```

</CodeSurfer>


<Logo/>

<Notes>

  - Al igual que el destructuring ponemos ejemplos y explicamos sobre array, pero realmente el for of se puede aplicar a cualquier iterable (Por ejemplo a un String o un Set).

</Notes>

---

## Objects

- Object methods
- Destructuring
  - Rest parameter
  - Spread operator
- Classes
- Enhanced object literals
- Optional chaining

<Logo/>

<Notes>

  -

</Notes>

---

<CodeSurfer>

```javascript title="String methods (padding)"
  const cardNumber = '01234567898765'

  const lastFourDigits = cardNumber.slice(-4)
  lastFourDigits.padStart(cardNumber.length, '*') // **********8765

  const firstFourDigits = cardNumber.slice(0, 4)
  firstFourDigits.padEnd(cardNumber.length, '*') // 0123**********
```

</CodeSurfer>

<Logo/>

<Notes>

  -

</Notes>

---

<CodeSurfer>

```javascript title="String methods (trim)"
  const message = '   Hello world!   '

  message.trimStart()   // 'Hello world!   '
  message.trimEnd()     // '   Hello world!'
```

</CodeSurfer>

<Logo/>

<Notes>

  -

</Notes>

---

<CodeSurfer>

```javascript title="Template literals"
const firstName = 'John'
console.log(`Hello ${firstName}!
Good morning!`)

// ouput:
Hello John!
Good morning!
```

</CodeSurfer>

<Logo/>

<Notes>

  -

</Notes>

---

<CodeSurfer>

```javascript title="Nullish coalescing operator"
  const car = { name: "", speed: 0  }


  console.log(car.name  || "Unknown")  // "Unknown"
  console.log(car.speed || 90)         // 90

  console.log(car.name  ?? "Unknown")  // ""
  console.log(car.speed ?? 90)         // 0
```

</CodeSurfer>

<Logo/>

<Notes>

  -

</Notes>
