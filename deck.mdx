import {CodeSurfer} from "code-surfer";
import {Notes} from 'mdx-deck'

import { Logo, Table, Column } from './components'
import logo from './assets/logo.png'

# Javascript Moderno

<img src={logo} width="250px"/>

<Logo/>

<Notes>

  - https://devhints.io/es6
  - ¿Qué se considera JavaScript moderno? Podemos definir como JavaScript moderno al JavaScript a partir de ES2015, ya que a partir de esta versión el lenguaje dió un salto de calidad. Esto sumado al compromiso por parte de Ecma international y la comunidad de JavaScript de lanzar una nueva versión cada año añadiendo las nuevas funcionalidades. Todo esto junto con Node.js conllevó a una explosión en cuanto al uso del lenguaje y herramientas del ecosistema. Todo esto permite un desarrollo en JavaScript más rápido y seguro que antes.

</Notes>

---

### ¡Novedades!

<Table>
  <Column title="ES2015">
    <ul>
      <li>Variable Scoping</li>
      <li>Arrow functions</li>
      <li>Classes</li>
      <li>Enhanced object literals</li>
      <li>Template literals</li>
      <li>Destructuring</li>
      <li>Default parameters</li>
      <li>Rest parameter</li>
      <li>Spread Operator</li>
      <li>Iterators & For..of</li>
      <li>Generators</li>
      <li>Modules</li>
      <li>Set</li>
      <li>Weakset</li>
      <li>Map</li>
      <li>Weakmap</li>
      <li>Unicode</li>
      <li>Proxies</li>
      <li>Symbols</li>
      <li>Promises</li>
      <li>Reflect</li>
      <li>Binary and Octal</li>
      <li>Proper Tail calls</li>
      <li>Array find methods</li>
    </ul>
  </Column>
  <Column title="ES2016">
    <ul>
      <li>Array includes</li>
      <li>Exponentiation Operator</li>
    </ul>
  </Column>
  <Column title="ES2017">
    <ul>
      <li>Async functions</li>
      <li>Object values</li>
      <li>Object entries</li>
      <li>Object property descriptors</li>
      <li>String padding</li>
      <li>Shared memory and atomics</li>
      <li>Trailing commas</li>
    </ul>
  </Column>
  <Column title="ES2018">
    <ul>
      <li>Async iterators</li>
      <li>Object rest and spread operators</li>
      <li>Promise finally</li>
    </ul>
  </Column>
  <Column title="ES2019">
    <ul>
      <li>Array flat and flatMap</li>
      <li>Object fromEntries</li>
      <li>String trimStart and trimEnd</li>
      <li>Symbol description</li>
      <li>Optional Catch Binding</li>
      <li>JSON Improvements</li>
      <li>Array Stable Sort</li>
      <li>Function.toString()</li>
      <li>Private Class Variable</li>
    </ul>
  </Column>
  <Column title="ES2020">
    <ul>
      <li>BigInt</li>
      <li>Dynamic Import</li>
      <li>Nullish Coalescing Operator</li>
      <li>Optional chaining</li>
      <li>Promise allSettled</li>
      <li>String matchAll</li>
      <li>globalThis</li>
      <li>import.meta</li>
      <li>for..in order</li>
    </ul>
  </Column>
  <Column title="ES2021">
    <ul>
      <li>String replaceAll</li>
      <li>Promise any</li>
      <li>AggregateError</li>
      <li>Logical assigment operators (??=, &&=, ||=)</li>
      <li>WeakRef</li>
      <li>FinalizationRegistry</li>
      <li>Separators for numeric literals (1_000)</li>
      <li>Array.prototype.sort</li>
    </ul>
  </Column>
</Table>

<Logo/>

<Notes>

  - Esto son todas las cosas nuevas que han entrado desde 2015,
    pero esto no significa que vayamos a presentarlas todas, es para que les entre curiosidad

</Notes>

---

<CodeSurfer>

```javascript title="Variable scoping"
var a = 1;

if (a === 1) {
  var a = 2;

  console.log(a); // 2
}

console.log(a); // 2
```

```javascript title="Variable scoping"
let a = 1;

if (a === 1) {
  let a = 2;

  console.log(a); // 2
}

console.log(a); // 1
```

```javascript title="Variable scoping"
const x = 1;

if (x === 1) {
  const x = 2;

  console.log(x); // 2
}

console.log(x); // 1
```

```javascript title="Variable scoping"
const x = 1;

if (x === 1) {
  const x = 2;

  console.log(x); // 2
}
x = 3 // throw SyntaxError

console.log(x); // 1
```

</CodeSurfer>

<Logo/>

<Notes>

  - `var` es como se han definido variables en JavaScript desde el principio de los tiempos. Sin embargo, presenta una serie de problemas:
    - Su ámbito es global dentro de la función que está, por lo que desde cualquier lugar de la función puedes llegar a cambiar algunos valores derivando en resultados inesperados. `let` y `const` lanzarían un `ReferenceError`
    - Puede ser usada antes de ser declarada, usando `let` o `const` lanzaría un `ReferenceError`
    -

</Notes>

---

## Modules

Content

<Logo/>

<Notes>

  -

</Notes>

---

<CodeSurfer>

```javascript title="Arrow functions"
// Function
const add = function (a, b) {
  return a + b;
}

// Arrow function
const add = (a, b) => a + b
```

</CodeSurfer>

<Logo/>

<Notes>

  - Aunque parezca que es azúcar sintáctico, realmente hay una ligera diferencia. En el caso de las funciones de toda la vida, tienen su propio this, mientras que las arrow functions usan el this del scope en el que están.
  - Las arrow functions es mejor usarlas como funciones anónimas, como métodos y demás darán errores, ya que no tienen ni idea del this.

</Notes>

---

<CodeSurfer>

```javascript title="Default parameters in functions"
const add = (a = 10, b = 20) => a + b

add(5, 5) // 10
add(5)    // 25
add()     // 30
```

</CodeSurfer>

<Logo/>

<Notes>

  - Los parámetros por defecto em las funciones pueden ser llamadas a otras funciones en incluso otros parámetros anteriores.

</Notes>

---

## Asincronía - Promise

Content

<Logo/>

<Notes>

  -

</Notes>

---

## Arrays - Métodos nuevos

<CodeSurfer>

```js title="Array.prototype.find"
const numberList = [10, 20, 30, 40, 50]

numberList.find(x => x > 25) // 30
```

```js title="Array.prototype.find"
const numberList = [10, 20, 30, 40, 50]

numberList.find(x => x > 60) // undefined
```

</CodeSurfer>

<Logo/>

<Notes>

  - Devuelve el primer elemento que resulva satisfactoriamente la condición.
  - Si no lo encuentra devuelve undef

</Notes>

---

## Arrays - Métodos nuevos

<CodeSurfer>

```js title="Array.prototype.includes"
const numberList = [10, 20, 30, 40, 50]

numberList.includes(20) // true
numberList.includes(25) // false
```

</CodeSurfer>

<Logo/>

<Notes>

  - Muy útil para valores primitivos, pero algo inestable para objetos, ya que comparará por referencia y no por valor.

</Notes>

---

## Arrays - Destructuring

<CodeSurfer>

```js title="Array destructuring"
const [one, two, three] = [1,2,3]

one // 1
two // 2
three // 3
```

```js title="Array destructuring"
const [one, two, three, four] = [1,2,3]

one // 1
two // 2
three // 3
four // undefined
```

```js title="Array destructuring"
const [one, two, three] = 'Hi!'

one // 'H'
two // 'i'
three // '!'
```

</CodeSurfer>

<Logo/>

<Notes>

  - Ponemos ejemplos y explicamos sobre array, pero realmente este tipo de destructuring se puede aplicar a cualquier iterable (Por ejemplo a un String o un Set).
  - Se basa a en las posiciones

</Notes>

---

## Arrays - Destructuring

<CodeSurfer>

```js title="Rest parameter"
const [ten, ...restOfNumbers] = [10, 20, 30, 40, 50]

ten // 10
restOfNumbers // [20, 30, 40, 50]
```

```js title="Rest parameter"
  const [ten, ...restOfNumbers, fifty] = [10, 20, 30, 40, 50]
  // throw SyntaxError: Rest element must be last element
```

</CodeSurfer>

<Logo/>

<Notes>

  - Los rest parameters se usa para agrupar todos los elementos restantes del array en una variable. Es como decir quiero esto, aquello y lo otro y el resto me lo pones en un tupper para llevar.
  - Debe ser el último valor, de lo contrario lanzará un SyntaxError
  - En el caso de rest parameter el uso de la elipsis se hace de cara a la definición de la variable.

</Notes>

---

## Arrays - Destructuring

<CodeSurfer>

```js title="Spread operator"
const workdays = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes']
const weekend = ['Sábado', 'Domingo']
const week = [...workdays, ...weekend]

week // [ "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"]
```

</CodeSurfer>

<Logo/>

<Notes>

  - El spread operator al contrario que el rest parameters divide en vez de agrupar.
  - Se suele usar mucho para clonar arrays, ya que al usarlo genera un nuevo array de cero, en vez de hacer referencias a memoria.
  - El orden en el que hacemos el spread importa, ya que el array final seguirá ese orden.
  - En el caso del spread operator el uso de la elipsis se hace de cara a la asignación de la variable.

</Notes>

---

## Arrays - Destructuring

Artículo que explica el destructuring de Array:

[https://ulisesantana.dev/blog/2021/array-destructuring/](https://ulisesantana.dev/blog/2021/array-destructuring/)

<Logo/>

<Notes>

  -

</Notes>

---

## Arrays - For of


<CodeSurfer>

```js title="For of"
const numberList = [10, 20, 30, 40, 50]

for (const value of numberList) {
  console.log(value)
}
```

```js title="For of"
const numberList = [10, 20, 30, 40, 50]

for (const [index, value] of numberList.entries()) {
  console.log(`Number ${value} at position ${index}`)
}
```

</CodeSurfer>


<Logo/>

<Notes>

  - Al igual que el destructuring ponemos ejemplos y explicamos sobre array, pero realmente el for of se puede aplicar a cualquier iterable (Por ejemplo a un String o un Set).

</Notes>

---

## Objects

- Object methods
- Destructuring
  - Rest parameter
  - Spread operator
- Classes
- Enhanced object literals
- Optional chaining

<Logo/>

<Notes>

  -

</Notes>

---

<CodeSurfer>

```javascript title="String methods (padding)"
  const cardNumber = '01234567898765'

  const lastFourDigits = cardNumber.slice(-4)
  lastFourDigits.padStart(cardNumber.length, '*') // **********8765

  const firstFourDigits = cardNumber.slice(0, 4)
  firstFourDigits.padEnd(cardNumber.length, '*') // 0123**********
```

</CodeSurfer>

<Logo/>

<Notes>

  -

</Notes>

---

<CodeSurfer>

```javascript title="String methods (trim)"
  const message = '   Hello world!   '

  message.trimStart()   // 'Hello world!   '
  message.trimEnd()     // '   Hello world!'
```

</CodeSurfer>

<Logo/>

<Notes>

  -

</Notes>

---

<CodeSurfer>

```javascript title="Template literals"
const firstName = 'John'
console.log(`Hello ${firstName}!
Good morning!`)

// ouput:
Hello John!
Good morning!
```

</CodeSurfer>

<Logo/>

<Notes>

  -

</Notes>

---

<CodeSurfer>

```javascript title="Nullish coalescing operator"
  const car = { name: "", speed: 0  }


  console.log(car.name  || "Unknown")  // "Unknown"
  console.log(car.speed || 90)         // 90

  console.log(car.name  ?? "Unknown")  // ""
  console.log(car.speed ?? 90)         // 0
```

</CodeSurfer>

<Logo/>

<Notes>

  -

</Notes>
